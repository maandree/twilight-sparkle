/**
 * twilight-sparkle – Bootkits detection software
 * 
 * Copyright © 2012  Mattias Andrée (maandree@kth.se)
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "randomgen.h"


/**
 * Cached static randomness
 */
static int cache = 0;

/**
 * Static random alpha component
 */
static int alpha = 0;

/**
 * Static random beta component
 */
static int beta = 0;

/**
 * Weak random file descriptor
 */
static FILE* weak = 0;

/**
 * Strong random file descriptor
 */
static FILE* strong = 0;



/**
 * Initialise random generator
 * 
 * @param  usestatuc  Whether to initialise or re-initialise static random generator
 * @param  useweak    Whether to initialise weak random generator
 * @param  usestrong  Whether to initialise strong random generator
 */
static void init_random(int usestatic, int useweak, int usestrong)
{
  if (usestatic)
    {
      cache = -1;
      alpha = 1092476172;
      beta = 846202358;
    }
  
  if (useweak)    weak   = fopen("/dev/urandom", "r");
  if (usestrong)  strong = fopen("/dev/random",  "r");
}


/**
 * Terminate non-static random generator
 * 
 * @param  usestatic  Whether to terminate static random generator
 * @param  useweak    Whether to terminate weak random generator
 * @param  usestrong  Whether to terminate strong random generator
 */
static void term_random(int usestatic, int useweak, int usestrong)
{
  (void) usestatic;
  
  if (useweak)    fclose(weak);
  if (usestrong)  fclose(strong);
}


/**
 * Get a random number generated by a method that will always put
 * out the same sequence after the last initalisation.
 * 
 * @return  A random byte
 */
static char static_random()
{
  char rc = cache & 0xFF;
  if (cache == -1)
    {
      alpha = 36969 * (alpha & 0xFFFF) + (alpha >> 16);
      beta  = 18000 * (beta  & 0xFFFF) + (beta  >> 16);
      cache = (alpha << 16) + beta;
      rc = cache & 0xFF;
      cache = (cache >> 8) | 0xFF000000;
    }
  else
    cache >>= 8;
  return rc;
}


/**
 * Get a random number that is fast and not static
 * 
 * @return  A random byte
 */
static char weak_random()
{
  return fgetc(weak);
}


/**
 * Get a random number that is strong and not static
 * 
 * @return  A random byte
 */
static char strong_random()
{
  return fgetc(strong);
}

